#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import print_function, unicode_literals
import argparse
import glob
import io
import json
import pprint
import six
import sys
import os.path

from intelmq import DEFAULT_LOGGING_PATH


if sys.version_info[0] == 2:
    input = raw_input

APPNAME = "intelmqdump"
DESCRIPTION = """
description: intelmqctl is the tool to control intelmq system."""
USAGE = '''intelmqdump [botid]'''
# shortcut: description, takes ids, available for corrupted files
ACTIONS = {'r': ('(r)ecover by ids', True, False),
           'a': ('recover (a)ll', False, False),
           'e': ('delete (e)ntries', True, False),
           'd': ('(d)elete file', False, True),
           's': ('(s)how by ids', True, False),
           'q': ('(q)uit', False, True),
           }
AVAILABLE_IDS = [key for key, value in ACTIONS.items() if value[1]]


def dump_info(fname):
    info = 'defect'
    try:
        handle = io.open(fname, 'rt')
    except OSError as exc:
        info = 'unable to open file: {!s}'.format(exc)
    else:
        try:
            content = json.load(handle)
        except ValueError as exc:
            info = 'unable to load JSON: {!s}'.format(exc)
        else:
            try:
                info = "{!s} dumps".format(len(content.keys()))
            except AttributeError as exc:
                info = "unable to count dumps: {!s}".format(exc)
    finally:
        try:
            handle.close()
        except NameError:
            pass
    return info


def save_file(fname, content):
    with open(fname, 'wt') as handle:
        json.dump(content, handle)


def load_meta(dump):
    retval = []
    for key, value in dump.items():
        error = value['traceback'].splitlines()[-1]
        if len(error) > 200:
            error = error[:100] + '...' + error[-100:]
        retval.append((key, error))
    return retval


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog=APPNAME,
        usage=USAGE,
        epilog=DESCRIPTION
    )

    parser.add_argument('botid', metavar='botid', nargs='?',
                        default=None, help='botid to inspect dumps of')
    args = parser.parse_args()

    if args.botid is None:
        filenames = glob.glob(os.path.join(DEFAULT_LOGGING_PATH, '*.dump'))
        filenames = [(fname, fname[len(DEFAULT_LOGGING_PATH):-5])
                     for fname in filenames]

        length = max([len(value[1]) for value in filenames])
        for count, (fname, shortname) in enumerate(filenames):
            info = dump_info(fname)
            print("{c:3}: {s:{l}} {i}".format(c=count, s=shortname, i=info,
                                              l=length))
        botid = input('Which dump file to process (number or name)? ')
        try:
            fname, botid = filenames[int(botid)]
        except ValueError:
            fname = os.path.join(DEFAULT_LOGGING_PATH, botid) + '.dump'
    else:
        botid = args.botid
        fname = os.path.join(DEFAULT_LOGGING_PATH, botid) + '.dump'
        info = dump_info(fname)

    if not os.path.isfile(fname):
        print('Given file does not exist: {}'.format(fname))
        exit(1)
    while True:
        print ('Processing {}: {}'.format(botid, dump_info(fname)))
        try:
            with io.open(fname, 'rt') as handle:
                content = json.load(handle)
            meta = load_meta(content)
        except ValueError as exc:
            available_opts = [item[0] for item in ACTIONS.values() if item[2]]
            print('Could not load file: {}\nRestricted actions.'.format(exc))
        else:
            available_opts = [item[0] for item in ACTIONS.values()]
            for count, line in enumerate(meta):
                print('{:3}: {} {}'.format(count, *line))
        answer = input(', '.join(available_opts) + '? ').strip()
        if any([answer.startswith(char) for char in AVAILABLE_IDS]):
            ids = [int(id) for id in answer[1:].split(',')]
            print(ids)
        if answer == 'a':
            answer = 'r'
            ids = range(len(meta))
        if answer == 'q':
            break
        elif answer.startswith('e'):
            # Delete entries
            for entry in ids:
                del content[meta[entry][0]]
            save_file(fname, content)
        elif answer.startswith('r'):
            raise NotImplementedError
        elif answer.startswith('d'):
            os.remove(fname)
            break
        elif answer.startswith('s'):
            for count, (key, value) in enumerate(content.iteritems()):
                if count in ids:
                    print('='*100, '\nShowing id {} {}\n'.format(count, key),
                          '-'*50)
                    pprint.pprint(value)
