{
  "report": {
    "raw": {
      "type": "Base64",
      "description": "The original raw and unparsed data encoded in base64.",
      "length": "2000"
    },
    "feed.name": {
      "type": "String",
      "description": "Name for the feed, usually found in collector bot configuration.",
      "length": "2000"
    },
    "feed.url": {
      "type": "URL",
      "description": "The URL of a given abuse feed, where applicable.",
    },
    "time.observation": {
      "type": "DateTime",
      "description": "The time a source bot saw the event. This timestamp becomes especially important should you perform your own attribution on a host DNS name for example. The mechanism to denote the attributed elements with reference to the source provided is detailed below in Reported Identity IOC.(ISO8660)."
    }
  },
  "event": {
    "raw": {
      "type": "Base64",
      "description": "The original line of the event from encoded in base64.",
      "length": "2000"
    },
    "feed.name": {
      "type": "FeedName",
      "description": "Name for the feed, usually found in collector bot configuration.",
      "length": "2000"
    },
    "feed.url": {
      "type": "URL",
      "description": "The URL of a given abuse feed, where applicable.",
      "length": "2000"
    },
    "time.source": {
      "type": "DateTime",
      "description": "Time reported by a source. Some sources only report a date, which may be used here if there is no better observation."
    },
    "time.observation": {
      "type": "DateTime",
      "description": "The time a source bot saw the event. This timestamp becomes especially important should you perform your own attribution on a host DNS name for example. The mechanism to denote the attributed elements with reference to the source provided is detailed below in Reported Identity IOC.(ISO8660)."
    },
    "classification.type": {
      "type": "ClassificationType",
      "description": "The abuse type IOC is one of the most crucial pieces of information for any given abuse event. The main idea of dynamic typing is to keep our ontology flexible, since we need to evolve with the evolving threatscape of abuse data. In contrast with the static taxonomy below, the dynamic typing is used to perform business decisions in the abuse handling pipeline. Furthermore, the value data set should be kept as minimal as possible to avoid “type explosion”, which in turn dilutes the business value of the dynamic typing. In general, we normally have two types of abuse type IOC: ones referring to a compromized resource or ones referring to pieces of the criminal infrastructure, such as a command and control servers for example.",
      "length": "2000"
    },
    "classification.taxonomy": {
      "type": "String",
      "description": "We recognize the need for the CSIRT teams to apply a static (incident) taxonomy to abuse data. With this goal in mind the type IOC will serve as a basis for this activity. Each value of the dynamic type mapping translates to a an element in the static taxonomy. The European CSIRT teams for example have decided to apply the eCSIRT.net incident classification. The value of the taxonomy key is thus a derivative of the dynamic type above. For more information about check [ENISA taxonomies](http://www.enisa.europa.eu/activities/cert/support/incident-management/browsable/incident-handling-process/incident-taxonomy/existing-taxonomies).",
      "length": "2000"
    },
    "source.ip": {
      "type": "IPAddress",
      "description": "The ip observed to initiate the connection",
      "regex": "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$"
    },
    "source.tor_node": {
      "type": "String",
      "description": "TODO: Description"
    },
    "source.network": {
      "type": "IPNetwork",
      "description": "TODO: Description"
    },
    "source.fqdn": {
      "type": "FQDN",
      "description": "A DNS name related to the host from which the connection originated.",
      "regex": "^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9-]*[A-Za-z0-9])$"
    },
    "source.reverse_domain_name": {
      "type": "FQDN",
      "description": "Reverse DNS name acquired through a reverse DNS query on an IP address. N.B. Record types other than PTR records may also appear in the reverse DNS tree. Furthermore, unfortunately, there is no rule prohibiting people from writing anything in a PTR record. Even Javascript will work.",
      "length": "2000"
    },
    "source.url": {
      "type": "URL",
      "description": "A URL denotes an IOC, which refers to a malicious resource, whose interpretation is defined by the abuse type. A URL with the abuse type phishing refers to a phishing resource.",
      "length": "2000"
    },
    "source.account": {
      "type": "String",
      "description": "TODO: Description"
    },
    "source.port": {
      "type": "String",
      "description": "The port from which the connection originated. TODO: Integer",
      "regex": "^[0-9]{1,5}$"
    },
    "source.asn": {
      "type": "String",
      "description": "The autonomous system number from which originated the connection. TODO: 32bit Integer"
    },
    "source.bgp_prefix": {
      "type": "String",
      "description": "CIDR for an autonomous system. TODO: dbtype inet",
      "regex": "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}/[0-9]{1,3}$"
    },
    "source.registry": {
      "type": "String",
      "description": "The IP registry a given ip address is allocated by.",
      "length": "2000",
      "ascii": true
    },
    "source.allocated": {
      "type": "DateTime",
      "description": "Allocation date corresponding to bgp prefix."
    },
    "source.as_name": {
      "type": "String",
      "description": "The autonomous system name from which the connection originated.",
      "length": "2000",
      "ascii": true
    },
    "source.geolocation.cc": {
      "type": "String",
      "description": "MaxMind Country Code (ISO3166).",
      "length": "2",
      "regex": "^[a-zA-Z0-9]{2}$"
    },
    "source.geolocation.country": {
      "type": "String",
      "description": "The country name derived from the ISO3166 country code (assigned to cc field).",
      "length": "2000",
      "ascii": true
    },
    "source.geolocation.city": {
      "type": "String",
      "description": "Some geolocation services refer to city-level geolocation.",
      "length": "2000"
    },
    "source.geolocation.latitude": {
      "type": "String",
      "description": "Latitude coordinates derived from a geolocation service, such as MaxMind geoip db. TODO: float",
      "regex": "^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$"
    },
    "source.geolocation.longitude": {
      "type": "String",
      "description": "Longitude coordinates derived from a geolocation service, such as MaxMind geoip db. TODO: float",
      "regex": "^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$"
    },
    "source.abuse_contact": {
      "type": "String",
      "description": "TODO: Description"
    },
    "destination.ip": {
      "type": "IPAddress",
      "description": "The ip observed to initiate the connection.",
      "regex": "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$"
    },
    "destination.tor_node": {
      "type": "String",
      "description": "TODO: Description"
    },
    "destination.network": {
      "type": "IPNetwork",
      "description": "TODO: Description"
    },
    "destination.fqdn": {
      "type": "FQDN",
      "description": "A DNS name related to the host to which the connection headed.",
      "regex": "^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9-]*[A-Za-z0-9])$"
    },
    "destination.reverse_domain_name": {
      "type": "FQDN",
      "description": "TODO: Description"
    },
    "destination.url": {
      "type": "URL",
      "description": "A URL denotes on IOC, which refers to a malicious resource, whose interpretation is defined by the abuse type. A URL with the abuse type phishing refers to a phishing resource.",
      "length": "2000"
    },
    "destination.account": {
      "type": "String",
      "description": "TODO: Description"
    },
    "destination.port": {
      "type": "String",
      "description": "The port to which the connection headed. TODO: Integer",
      "regex": "^[0-9]{1,5}$"
    },
    "destination.asn": {
      "type": "String",
      "description": "The autonomous system number from which originated the connection. TODO: 32bit Integer"
    },
    "destination.bgp_prefix": {
      "type": "String",
      "description": "CIDR for an autonomous system. TODO: dbtype inet",
      "regex": "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}/[0-9]{1,3}$"
    },
    "destination.registry": {
      "type": "String",
      "description": "The IP registry a given ip address is allocated by.",
      "length": "2000",
      "ascii": true
    },
    "destination.allocated": {
      "type": "DateTime",
      "description": "Allocation date corresponding to bgp prefix."
    },
    "destination.as_name": {
      "type": "String",
      "description": "The autonomous system name to which the connection headed.",
      "length": "2000",
      "ascii": true
    },
    "destination.geolocation.cc": {
      "type": "String",
      "description": "MaxMind Country Code (ISO3166).",
      "length": "2",
      "regex": "^[a-zA-Z0-9]{2}$"
    },
    "destination.geolocation.country": {
      "type": "String",
      "description": "The country name derived from the ISO3166 country code (assigned to cc field).",
      "length": "2000",
      "ascii": true
    },
    "destination.geolocation.city": {
      "type": "String",
      "description": "Some geolocation services refer to city-level geolocation.",
      "length": "2000"
    },
    "destination.geolocation.latitude": {
      "type": "String",
      "description": "Latitude coordinates derived from a geolocation service, such as MaxMind geoip db. TODO: float",
      "regex": "^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$"
    },
    "destination.geolocation.longitude": {
      "type": "String",
      "description": "Longitude coordinates derived from a geolocation service, such as MaxMind geoip db. TODO: float",
      "regex": "^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$"
    },
    "destination.abuse_contact": {
      "type": "String",
      "description": "TODO: Description"
    },
    "protocol.application": {
      "type": "String",
      "description": "e.g. vnc, ssh, sip, irc, http or p2p.",
      "length": 5,
      "ascii": true
    },
    "malware.name": {
      "type": "MalwareName",
      "description": "A malware family name in lower case.",
      "regex": "[a-z ]+",
      "length": "2000"
    },
    "description.target": {
      "type": "String",
      "description": "Some sources denominate the target (organization) of a an attack.",
      "length": "2000"
    },
    "description.text": {
      "type": "String",
      "description": "A free-form textual description of an abuse event.",
      "length": "2000",
      "ascii": true
    },
    "description.url": {
      "type": "URL",
      "description": "A description URL is a link to a further description of the the abuse event in question.",
      "length": "2000"
    },
    "comment": {
      "type": "String",
      "description": "Free text commentary about the abuse event inserted by an analyst.",
      "length": "2000",
      "ascii": true
    }
  }
}
